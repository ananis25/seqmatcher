"""
This module parses the input string into a match/replace instruction. 
"""

import parsy as p

from .primitives import *


def generate(name: str):
    """Tags the parser generated by `parsy` with a name; appease the type-checker."""

    def decorator(fn):
        return p.generate(fn).desc(name)

    return decorator


# read a positive integer value
integer = p.digit.at_least(1).concat().map(int).desc("number")


@generate("slice")
def slice_():
    """read a range value written as `start..end`"""
    st = yield integer.optional()
    yield p.string("..")
    end = yield integer.optional()
    return st, end


# read either a range or a number, bracketed
count = p.string("[") >> (slice_ | integer) << p.string("]")


@generate("property")
def prop():
    key_str = yield p.regex(r"[\w_]+")
    op_str = yield p.regex(r"=|!=|<=|>=|<|>").desc("operator")
    val_str = yield p.regex(r"@?[\w_]+").sep_by(p.string("|"), min=1)

    if op_str not in ("=", "!="):
        val_str = val_str[0]
    return Property(cast_operator(op_str), key_str, val_str, [], [])


@generate("event")
def event():
    evt = EvtPattern()

    # read the number of times it should appear
    number = yield count.optional()
    if number is None:
        evt.min_count = 1
        evt.max_count = 1
    elif isinstance(number, int):
        evt.min_count = number
        evt.max_count = number
    else:
        evt.min_count = number[0] if number[0] is not None else 0
        evt.max_count = number[1]

    if evt.max_count is not None:
        assert evt.max_count >= evt.min_count
        assert evt.max_count > 0

    yield p.string("(")
    # read the custom name for the event
    custom_name = yield p.regex(r"@\w+").desc("custom_name").optional()
    if custom_name is not None:
        evt.custom_name = custom_name

    # read the event names to include/exclude
    exclude = yield p.string("!").optional()
    names = yield (p.string(":") >> p.regex(r"@?\w+").desc("type")).sep_by(
        p.string("|")
    )
    evt.flag_exclude_names = exclude is not None
    for name in names:
        evt.list_names.append(name)

    # read the properties to match
    tmp = yield p.string("{").optional()
    if tmp is not None:
        properties = yield prop.sep_by(p.string(","))
        evt.properties.extend(properties)
        yield p.string("}")

    yield p.string(")")
    return evt


@generate("pattern")
def pattern():
    pat = SeqPattern()

    tmp = yield p.string("|").optional()
    if tmp is not None:
        pat.match_seq_start = True

    start_mark = p.string("^")
    end_mark = p.string("$")
    token = start_mark | end_mark | event

    tokens = yield token.sep_by(p.string("-"))
    for tok in tokens:
        if tok == "^":
            if pat.idx_start_event is not None:
                raise Exception("multiple start event markers in the pattern")
            pat.idx_start_event = len(pat.events)
        elif tok == "$":
            if pat.idx_end_event is not None:
                raise Exception("multiple end event markers in the pattern")
            pat.idx_end_event = len(pat.events) - 1
        else:
            pat.events.append(tok)

    tmp = yield p.string("|").optional()
    if tmp is not None:
        pat.match_seq_end = True

    # read the properties to match
    tmp = yield p.string("{{").optional()
    if tmp is not None:
        properties: list[Property] = yield prop.sep_by(p.string(","))
        for _prop in properties:
            assert isinstance(_prop.value, str)
            if _prop.key == "_match_all":
                assert _prop.op == Operator.EQ
                pat.match_all = True if _prop.value.lower() == "true" else False
            elif _prop.key == "_allow_overlaps":
                assert _prop.op == Operator.EQ
                pat.allow_overlaps = True if _prop.value.lower() == "true" else False
            else:
                pat.properties.append(_prop)
        yield p.string("}}")

    return pat
